.. index:: pair: page; Chapter 4: Passing a remote command
.. _doxid-libssh_tutor_command:

Chapter 4: Passing a remote command
===================================



.. _doxid-libssh_tutor_command_1remote_command:

Passing a remote command
~~~~~~~~~~~~~~~~~~~~~~~~

Previous chapter has shown how to open a full shell session, with an attached terminal or not. If you only need to execute a command on the remote end, you don't need all that complexity.

The method described here is suited for executing only one remote command. If you need to issue several commands in a row, you should consider using a non-interactive remote shell, as explained in previous chapter.



.. _doxid-libssh_tutor_command_1exec_remote:

Executing a remote command
--------------------------

The first steps for executing a remote command are identical to those for opening remote shells. You first need a SSH channel, and then a SSH session that uses this channel:

.. ref-code-block:: cpp

	int show_remote_files(ssh_session session)
	{
	  ssh_channel channel;
	  int rc;
	
	  channel = ssh_channel_new(session);
	  if (channel == NULL) return SSH_ERROR;
	
	  rc = ssh_channel_open_session(channel);
	  if (rc != SSH_OK)
	  {
	    ssh_channel_free(channel);
	    return rc;
	  }

Once a session is open, you can start the remote command with :ref:`ssh_channel_request_exec() <doxid-group__libssh__channel_1ga567d509183ade0a77190f390e2b5747d>` :

.. ref-code-block:: cpp

	rc = ssh_channel_request_exec(channel, "ls -l");
	if (rc != SSH_OK)
	{
	  ssh_channel_close(channel);
	  ssh_channel_free(channel);
	  return rc;
	}

If the remote command displays data, you get them with :ref:`ssh_channel_read() <doxid-group__libssh__channel_1gac92381c4c5d4a7eab35f6e84686f033d>`. This function returns the number of bytes read. If there is no more data to read on the channel, this function returns 0, and you can go to next step. If an error has been encountered, it returns a negative value:

.. ref-code-block:: cpp

	char buffer[256];
	int nbytes;
	
	nbytes = ssh_channel_read(channel, buffer, sizeof(buffer), 0);
	while (nbytes > 0)
	{
	  if (fwrite(buffer, 1, nbytes, stdout) != nbytes)
	  {
	    ssh_channel_close(channel);
	    ssh_channel_free(channel);
	    return SSH_ERROR;
	  }
	  nbytes = ssh_channel_read(channel, buffer, sizeof(buffer), 0);
	}
	
	if (nbytes < 0)
	{
	  ssh_channel_close(channel);
	  ssh_channel_free(channel);
	  return SSH_ERROR;
	}

Once you read the result of the remote command, you send an end-of-file to the channel, close it, and free the memory that it used:

.. ref-code-block:: cpp

	  ssh_channel_send_eof(channel);
	  ssh_channel_close(channel);
	  ssh_channel_free(channel);
	
	  return SSH_OK;
	}







.. rubric:: See also:

shell

