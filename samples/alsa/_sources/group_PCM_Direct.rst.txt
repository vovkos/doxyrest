.. index:: pair: group; Direct Access (MMAP) Functions
.. _doxid-group___p_c_m___direct:

Direct Access (MMAP) Functions
==============================

.. toctree::
	:hidden:

Overview
~~~~~~~~

See the :ref:`PCM (digital audio) interface <doxid-pcm>` page for more details. :ref:`More...<details-group___p_c_m___direct>`


.. ref-code-block:: cpp
	:class: doxyrest-overview-code-block

	
	// global functions

	int
	:ref:`snd_pcm_mmap_begin<doxid-group___p_c_m___direct_1ga6d4acf42de554d4d1177fb035d484ea4>`(
		:ref:`snd_pcm_t<doxid-group___p_c_m_1ga919e634deecd855b6e2e15174e70d3ea>`* pcm,
		const :ref:`snd_pcm_channel_area_t<doxid-structsnd__pcm__channel__area__t>`** areas,
		:ref:`snd_pcm_uframes_t<doxid-group___p_c_m_1gab01fcfe9b97382a8d3f2027c664b8b8a>`* offset,
		:ref:`snd_pcm_uframes_t<doxid-group___p_c_m_1gab01fcfe9b97382a8d3f2027c664b8b8a>`* frames
	);

	:ref:`snd_pcm_sframes_t<doxid-group___p_c_m_1ga71cdfa37e258d2210b8bd0216bf0c36c>`
	:ref:`snd_pcm_mmap_commit<doxid-group___p_c_m___direct_1gac306bd13c305825aa39dd9180a3ad520>`(
		:ref:`snd_pcm_t<doxid-group___p_c_m_1ga919e634deecd855b6e2e15174e70d3ea>`* pcm,
		:ref:`snd_pcm_uframes_t<doxid-group___p_c_m_1gab01fcfe9b97382a8d3f2027c664b8b8a>` offset,
		:ref:`snd_pcm_uframes_t<doxid-group___p_c_m_1gab01fcfe9b97382a8d3f2027c664b8b8a>` frames
	);

	:ref:`snd_pcm_sframes_t<doxid-group___p_c_m_1ga71cdfa37e258d2210b8bd0216bf0c36c>`
	:ref:`snd_pcm_mmap_writei<doxid-group___p_c_m___direct_1ga5a9ee8e1e764b12da6d54dfa195f7c52>`(
		:ref:`snd_pcm_t<doxid-group___p_c_m_1ga919e634deecd855b6e2e15174e70d3ea>`* pcm,
		const void* buffer,
		:ref:`snd_pcm_uframes_t<doxid-group___p_c_m_1gab01fcfe9b97382a8d3f2027c664b8b8a>` size
	);

	:ref:`snd_pcm_sframes_t<doxid-group___p_c_m_1ga71cdfa37e258d2210b8bd0216bf0c36c>`
	:ref:`snd_pcm_mmap_readi<doxid-group___p_c_m___direct_1ga24b6c538c8d7ddd0776ee65f8fb909eb>`(
		:ref:`snd_pcm_t<doxid-group___p_c_m_1ga919e634deecd855b6e2e15174e70d3ea>`* pcm,
		void* buffer,
		:ref:`snd_pcm_uframes_t<doxid-group___p_c_m_1gab01fcfe9b97382a8d3f2027c664b8b8a>` size
	);

	:ref:`snd_pcm_sframes_t<doxid-group___p_c_m_1ga71cdfa37e258d2210b8bd0216bf0c36c>`
	:ref:`snd_pcm_mmap_writen<doxid-group___p_c_m___direct_1ga092b1a7f387e9fc2977649bfd43b0958>`(
		:ref:`snd_pcm_t<doxid-group___p_c_m_1ga919e634deecd855b6e2e15174e70d3ea>`* pcm,
		void** bufs,
		:ref:`snd_pcm_uframes_t<doxid-group___p_c_m_1gab01fcfe9b97382a8d3f2027c664b8b8a>` size
	);

	:ref:`snd_pcm_sframes_t<doxid-group___p_c_m_1ga71cdfa37e258d2210b8bd0216bf0c36c>`
	:ref:`snd_pcm_mmap_readn<doxid-group___p_c_m___direct_1ga29ce9af60eafb67f0303418a176bf3ea>`(
		:ref:`snd_pcm_t<doxid-group___p_c_m_1ga919e634deecd855b6e2e15174e70d3ea>`* pcm,
		void** bufs,
		:ref:`snd_pcm_uframes_t<doxid-group___p_c_m_1gab01fcfe9b97382a8d3f2027c664b8b8a>` size
	);

.. _details-group___p_c_m___direct:

Detailed Documentation
~~~~~~~~~~~~~~~~~~~~~~

See the :ref:`PCM (digital audio) interface <doxid-pcm>` page for more details.

Global Functions
----------------

.. index:: pair: function; snd_pcm_mmap_begin
.. _doxid-group___p_c_m___direct_1ga6d4acf42de554d4d1177fb035d484ea4:

.. ref-code-block:: cpp
	:class: doxyrest-title-code-block

	int
	snd_pcm_mmap_begin(
		:ref:`snd_pcm_t<doxid-group___p_c_m_1ga919e634deecd855b6e2e15174e70d3ea>`* pcm,
		const :ref:`snd_pcm_channel_area_t<doxid-structsnd__pcm__channel__area__t>`** areas,
		:ref:`snd_pcm_uframes_t<doxid-group___p_c_m_1gab01fcfe9b97382a8d3f2027c664b8b8a>`* offset,
		:ref:`snd_pcm_uframes_t<doxid-group___p_c_m_1gab01fcfe9b97382a8d3f2027c664b8b8a>`* frames
	)

Application request to access a portion of direct (mmap) area.

It is necessary to call the :ref:`snd_pcm_avail_update() <doxid-group___p_c_m_1ga8bb836bd0c414b59789d51a5f5379c08>` function directly before this call. Otherwise, this function can return a wrong count of available frames.

The function should be called before a sample-direct area can be accessed. The resulting size parameter is always less or equal to the input count of frames and can be zero, if no frames can be processed (the ring buffer is full).

See the :ref:`snd_pcm_mmap_commit() <doxid-group___p_c_m___direct_1gac306bd13c305825aa39dd9180a3ad520>` function to finish the frame processing in the direct areas.

The function is thread-safe when built with the proper option.



.. rubric:: Parameters:

.. list-table::
	:widths: 20 80

	*
		- pcm

		- PCM handle

	*
		- areas

		- Returned mmap channel areas

	*
		- offset

		- Returned mmap area offset in area steps (== frames)

	*
		- frames

		- mmap area portion size in frames (wanted on entry, contiguous available on exit)



.. rubric:: Returns:

0 on success otherwise a negative error code

.. index:: pair: function; snd_pcm_mmap_commit
.. _doxid-group___p_c_m___direct_1gac306bd13c305825aa39dd9180a3ad520:

.. ref-code-block:: cpp
	:class: doxyrest-title-code-block

	:ref:`snd_pcm_sframes_t<doxid-group___p_c_m_1ga71cdfa37e258d2210b8bd0216bf0c36c>`
	snd_pcm_mmap_commit(
		:ref:`snd_pcm_t<doxid-group___p_c_m_1ga919e634deecd855b6e2e15174e70d3ea>`* pcm,
		:ref:`snd_pcm_uframes_t<doxid-group___p_c_m_1gab01fcfe9b97382a8d3f2027c664b8b8a>` offset,
		:ref:`snd_pcm_uframes_t<doxid-group___p_c_m_1gab01fcfe9b97382a8d3f2027c664b8b8a>` frames
	)

Application has completed the access to area requested with :ref:`snd_pcm_mmap_begin <doxid-group___p_c_m___direct_1ga6d4acf42de554d4d1177fb035d484ea4>`.

You should pass this function the offset value that :ref:`snd_pcm_mmap_begin() <doxid-group___p_c_m___direct_1ga6d4acf42de554d4d1177fb035d484ea4>` returned. The frames parameter should hold the number of frames you have written or read to/from the audio buffer. The frames parameter must never exceed the contiguous frames count that :ref:`snd_pcm_mmap_begin() <doxid-group___p_c_m___direct_1ga6d4acf42de554d4d1177fb035d484ea4>` returned. Each call to :ref:`snd_pcm_mmap_begin() <doxid-group___p_c_m___direct_1ga6d4acf42de554d4d1177fb035d484ea4>` must be followed by a call to :ref:`snd_pcm_mmap_commit() <doxid-group___p_c_m___direct_1gac306bd13c305825aa39dd9180a3ad520>`.

Example:

.. ref-code-block:: cpp

	 double phase = 0;
	 const snd_pcm_area_t *areas;
	 snd_pcm_sframes_t avail, size, commitres;
	 snd_pcm_uframes_t offset, frames;
	 int err;
	
	 avail = snd_pcm_avail_update(pcm);
	 if (avail < 0)
	   error(avail);
	 // at this point, we can transfer at least 'avail' frames
	 
	 // we want to process frames in chunks (period_size)
	 if (avail < period_size)
	   goto _skip;
	 size = period_size;
	 // it is possible that contiguous areas are smaller, thus we use a loop
	 while (size > 0) {
	   frames = size;
	
	   err = snd_pcm_mmap_begin(pcm_handle, &areas, &offset, &frames);
	   if (err < 0)
	     error(err);
	   // this function fills the areas from offset with count of frames
	   generate_sine(areas, offset, frames, &phase);
	   commitres = snd_pcm_mmap_commit(pcm_handle, offset, frames);
	   if (commitres < 0 || commitres != frames)
	     error(commitres >= 0 ? -EPIPE : commitres);
	     
	   size -= frames;
	 }
	_skip:

Look to the :ref:`Sine-wave generator <doxid-pcm_1example_test_pcm>` example for more details about the generate_sine function.

The function is thread-safe when built with the proper option.



.. rubric:: Parameters:

.. list-table::
	:widths: 20 80

	*
		- pcm

		- PCM handle

	*
		- offset

		- area offset in area steps (== frames)

	*
		- frames

		- area portion size in frames



.. rubric:: Returns:

count of transferred frames otherwise a negative error code

.. index:: pair: function; snd_pcm_mmap_writei
.. _doxid-group___p_c_m___direct_1ga5a9ee8e1e764b12da6d54dfa195f7c52:

.. ref-code-block:: cpp
	:class: doxyrest-title-code-block

	:ref:`snd_pcm_sframes_t<doxid-group___p_c_m_1ga71cdfa37e258d2210b8bd0216bf0c36c>`
	snd_pcm_mmap_writei(
		:ref:`snd_pcm_t<doxid-group___p_c_m_1ga919e634deecd855b6e2e15174e70d3ea>`* pcm,
		const void* buffer,
		:ref:`snd_pcm_uframes_t<doxid-group___p_c_m_1gab01fcfe9b97382a8d3f2027c664b8b8a>` size
	)

Write interleaved frames to a PCM using direct buffer (mmap)

If the blocking behaviour is selected, then routine waits until all requested bytes are played or put to the playback ring buffer. The count of bytes can be less only if a signal or underrun occurred.

If the non-blocking behaviour is selected, then routine doesn't wait at all.



.. rubric:: Parameters:

.. list-table::
	:widths: 20 80

	*
		- pcm

		- PCM handle

	*
		- buffer

		- frames containing buffer

	*
		- size

		- frames to be written

	*
		- -EBADFD

		- PCM is not in the right state (:ref:`SND_PCM_STATE_PREPARED <doxid-group___p_c_m_1gga61ac499cb3701ce536d4d83725908860a3eb4a3b75c7d2adb22f1829f3f738b27>` or :ref:`SND_PCM_STATE_RUNNING <doxid-group___p_c_m_1gga61ac499cb3701ce536d4d83725908860a86f6fbc796881f19fde0e1957f878147>`)

	*
		- -EPIPE

		- an underrun occurred

	*
		- -ESTRPIPE

		- a suspend event occurred (stream is suspended and waiting for an application recovery)



.. rubric:: Returns:

a positive number of frames actually written otherwise a negative error code

.. index:: pair: function; snd_pcm_mmap_readi
.. _doxid-group___p_c_m___direct_1ga24b6c538c8d7ddd0776ee65f8fb909eb:

.. ref-code-block:: cpp
	:class: doxyrest-title-code-block

	:ref:`snd_pcm_sframes_t<doxid-group___p_c_m_1ga71cdfa37e258d2210b8bd0216bf0c36c>`
	snd_pcm_mmap_readi(
		:ref:`snd_pcm_t<doxid-group___p_c_m_1ga919e634deecd855b6e2e15174e70d3ea>`* pcm,
		void* buffer,
		:ref:`snd_pcm_uframes_t<doxid-group___p_c_m_1gab01fcfe9b97382a8d3f2027c664b8b8a>` size
	)

Read interleaved frames from a PCM using direct buffer (mmap)

If the blocking behaviour was selected, then routine waits until all requested bytes are filled. The count of bytes can be less only if a signal or underrun occurred.

If the non-blocking behaviour is selected, then routine doesn't wait at all.



.. rubric:: Parameters:

.. list-table::
	:widths: 20 80

	*
		- pcm

		- PCM handle

	*
		- buffer

		- frames containing buffer

	*
		- size

		- frames to be written

	*
		- -EBADFD

		- PCM is not in the right state (:ref:`SND_PCM_STATE_PREPARED <doxid-group___p_c_m_1gga61ac499cb3701ce536d4d83725908860a3eb4a3b75c7d2adb22f1829f3f738b27>` or :ref:`SND_PCM_STATE_RUNNING <doxid-group___p_c_m_1gga61ac499cb3701ce536d4d83725908860a86f6fbc796881f19fde0e1957f878147>`)

	*
		- -EPIPE

		- an overrun occurred

	*
		- -ESTRPIPE

		- a suspend event occurred (stream is suspended and waiting for an application recovery)



.. rubric:: Returns:

a positive number of frames actually read otherwise a negative error code

.. index:: pair: function; snd_pcm_mmap_writen
.. _doxid-group___p_c_m___direct_1ga092b1a7f387e9fc2977649bfd43b0958:

.. ref-code-block:: cpp
	:class: doxyrest-title-code-block

	:ref:`snd_pcm_sframes_t<doxid-group___p_c_m_1ga71cdfa37e258d2210b8bd0216bf0c36c>`
	snd_pcm_mmap_writen(
		:ref:`snd_pcm_t<doxid-group___p_c_m_1ga919e634deecd855b6e2e15174e70d3ea>`* pcm,
		void** bufs,
		:ref:`snd_pcm_uframes_t<doxid-group___p_c_m_1gab01fcfe9b97382a8d3f2027c664b8b8a>` size
	)

Write non interleaved frames to a PCM using direct buffer (mmap)

If the blocking behaviour is selected, then routine waits until all requested bytes are played or put to the playback ring buffer. The count of bytes can be less only if a signal or underrun occurred.

If the non-blocking behaviour is selected, then routine doesn't wait at all.



.. rubric:: Parameters:

.. list-table::
	:widths: 20 80

	*
		- pcm

		- PCM handle

	*
		- bufs

		- frames containing buffers (one for each channel)

	*
		- size

		- frames to be written

	*
		- -EBADFD

		- PCM is not in the right state (:ref:`SND_PCM_STATE_PREPARED <doxid-group___p_c_m_1gga61ac499cb3701ce536d4d83725908860a3eb4a3b75c7d2adb22f1829f3f738b27>` or :ref:`SND_PCM_STATE_RUNNING <doxid-group___p_c_m_1gga61ac499cb3701ce536d4d83725908860a86f6fbc796881f19fde0e1957f878147>`)

	*
		- -EPIPE

		- an underrun occurred

	*
		- -ESTRPIPE

		- a suspend event occurred (stream is suspended and waiting for an application recovery)



.. rubric:: Returns:

a positive number of frames actually written otherwise a negative error code

.. index:: pair: function; snd_pcm_mmap_readn
.. _doxid-group___p_c_m___direct_1ga29ce9af60eafb67f0303418a176bf3ea:

.. ref-code-block:: cpp
	:class: doxyrest-title-code-block

	:ref:`snd_pcm_sframes_t<doxid-group___p_c_m_1ga71cdfa37e258d2210b8bd0216bf0c36c>`
	snd_pcm_mmap_readn(
		:ref:`snd_pcm_t<doxid-group___p_c_m_1ga919e634deecd855b6e2e15174e70d3ea>`* pcm,
		void** bufs,
		:ref:`snd_pcm_uframes_t<doxid-group___p_c_m_1gab01fcfe9b97382a8d3f2027c664b8b8a>` size
	)

Read non interleaved frames to a PCM using direct buffer (mmap)

If the blocking behaviour was selected, then routine waits until all requested bytes are filled. The count of bytes can be less only if a signal or underrun occurred.

If the non-blocking behaviour is selected, then routine doesn't wait at all.



.. rubric:: Parameters:

.. list-table::
	:widths: 20 80

	*
		- pcm

		- PCM handle

	*
		- bufs

		- frames containing buffers (one for each channel)

	*
		- size

		- frames to be written

	*
		- -EBADFD

		- PCM is not in the right state (:ref:`SND_PCM_STATE_PREPARED <doxid-group___p_c_m_1gga61ac499cb3701ce536d4d83725908860a3eb4a3b75c7d2adb22f1829f3f738b27>` or :ref:`SND_PCM_STATE_RUNNING <doxid-group___p_c_m_1gga61ac499cb3701ce536d4d83725908860a86f6fbc796881f19fde0e1957f878147>`)

	*
		- -EPIPE

		- an overrun occurred

	*
		- -ESTRPIPE

		- a suspend event occurred (stream is suspended and waiting for an application recovery)



.. rubric:: Returns:

a positive number of frames actually read otherwise a negative error code

