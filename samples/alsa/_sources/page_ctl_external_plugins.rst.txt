.. index:: pair: page; External Control Plugin SDK
.. _doxid-ctl_external_plugins:

External Control Plugin SDK
===========================



.. _doxid-ctl_external_plugins_1ctl_externals:

External Control Plugins
~~~~~~~~~~~~~~~~~~~~~~~~

The external plugins are implemented in a shared object file located at /usr/lib/alsa-lib (the exact location depends on the build option and asoundrc configuration). It has to be the file like libasound_module_ctl_MYPLUGIN.so, where MYPLUGIN corresponds to your own plugin name.

The entry point of the plugin is defined via :ref:`SND_CTL_PLUGIN_DEFINE_FUNC() <doxid-group___ctl_plugin___s_d_k_1ga13e494fe5c6068d6608a974f5a62a430>` macro. This macro defines the function with a proper name to be referred from alsa-lib. The function takes the following 5 arguments:

.. ref-code-block:: cpp

	int (snd_ctl_t **phandle, const char *name, snd_config_t *root,
	    snd_config_t *conf, int mode)

The first argument, phandle, is the pointer to store the resultant control handle. The arguments name, root and mode are the parameters to be passed to the plugin constructor. The conf is the configuration tree for the plugin. The arguments above are defined in the macro itself, so don't use variables with the same names to shadow parameters.

After parsing the configuration parameters in the given conf tree, usually you will call the external plugin API function :ref:`snd_ctl_ext_create() <doxid-group___ctl_plugin___s_d_k_1ga317775f9c5e239781e71735ca5ba1ca6>`. The control handle must be filled \*phandle in return. Then this function must return either a value 0 when succeeded, or a negative value as the error code.

Finally, add :ref:`SND_CTL_PLUGIN_SYMBOL() <doxid-group___ctl_plugin___s_d_k_1gaa94fc65e8951f16e4b273b0f81e90f7e>` with the name of your plugin as the argument at the end. This defines the proper versioned symbol as the reference.

The typical code would look like below:

.. ref-code-block:: cpp

	struct myctl_info {
	    snd_ctl_ext_t ext;
	    int my_own_data;
	    ...
	};
	
	SND_CTL_PLUGIN_DEFINE_FUNC(myctl)
	{
	    snd_config_iterator_t i, next;
	    struct myctl_info *myctl;
	    int err;
	
	    snd_config_for_each(i, next, conf) {
	        snd_config_t *n = snd_config_iterator_entry(i);
	        const char *id;
	        if (snd_config_get_id(n, &id) < 0)
	            continue;
	        if (strcmp(id, "comment") == 0 || strcmp(id, "type") == 0)
	            continue;
	        if (strcmp(id, "my_own_parameter") == 0) {
	            ....
	            continue;
	        }
	        SNDERR("Unknown field %s", id);
	        return -EINVAL;
	    }
	
	    myctl = calloc(1, sizeof(*myctl));
	    if (myctl == NULL)
	        return -ENOMEM;
	
	    myctl->ext.version = SND_CTL_EXT_VERSION;
	    myctl->ext.card_idx = 0;
	    strcpy(myctl->ext.id, "Myctl");
	    strcpy(myctl->ext.name, "My Control");
	    strcpy(myctl->ext.longname, "My External Control for Foobar");
	    strcpy(myctl->ext.mixername, "My Control");
	    myctl->ext.callback = &my_own_callback;
	    myctl->ext.private_data = myctl;
	    ....
	
	    err = snd_pcm_extplug_create(&myctl->ext, name, mode);
	    if (err < 0) {
	        myctl_free(myctl);
	        return err;
	    }
	
	     *phandle = myctl->ext.handle;
	    return 0;
	}
	
	SND_CTL_PLUGIN_SYMBOL(myctl);

Read the codes in alsa-plugins package for the real examples.





.. _doxid-ctl_external_plugins_1ctl_ext_impl:

Implementation of External Control Plugins
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The following fields have to be filled in external control record before calling :ref:`snd_ctl_ext_create() <doxid-group___ctl_plugin___s_d_k_1ga317775f9c5e239781e71735ca5ba1ca6>` : version, card_idx, id, name, longname, mixername, poll_fd and callback. Otherfields are optional and should be initialized with zero.

The constant :ref:`SND_CTL_EXT_VERSION <doxid-group___ctl_plugin___s_d_k_1ga65ea29f84b09ee3e640f88b06d05a1a2>` must be passed to the version field for the version check in alsa-lib. The card_idx field specifies the card index of this control. [FIXME: solve confliction of card index in alsa-lib?]

The id, name, longname and mixername fields are the strings shown in the card_info inqurirys. They are the char arrays, so you have to *copy* strings to these fields.

The callback field contains the table of callback functions for this plugin (defined as :ref:`snd_ctl_ext_callback_t <doxid-group___ctl_plugin___s_d_k_1ga8185c9a0e27e9562511a82dda1d20ddf>`). The poll_fd can be used to specify the poll file descriptor for this control. Set -1 if not available. Alternatively, you can define poll_descriptors_count and poll_descriptors callbacks in the callback table for handling the poll descriptor(s) dynamically after the creation of plugin instance.

The driver can set an arbitrary value (pointer) to private_data field to refer its own data in the callbacks.

The rest fields are filled by :ref:`snd_ctl_ext_create() <doxid-group___ctl_plugin___s_d_k_1ga317775f9c5e239781e71735ca5ba1ca6>`. The handle field is the resultant PCM handle. The others are the current status of the PCM.





.. _doxid-ctl_external_plugins_1ctl_ext_impl:

Implementation of External Control Plugins
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The callback functions in :ref:`snd_ctl_ext_callback_t <doxid-group___ctl_plugin___s_d_k_1ga8185c9a0e27e9562511a82dda1d20ddf>` define the real behavior of the driver. There are many callbacks but many of them are optional.

The close callback is called when the PCM is closed. If the plugin allocates private resources, this is the place to release them again. This callback is optional.

The elem_count and elem_list callbacks are mandatory. The elem_count returns the total number of control elements. The elem_list returns the control element ID of the corresponding element offset (the offset is from 0 to elem_count - 1). The id field is initialized to all zero in prior to elem_list callback. The callback has to fill the necessary field (typically iface, name and index) in return via the standard control API functions like :ref:`snd_ctl_elem_id_set_interface <doxid-group___control_1ga33855eaf0261c321cbf0a88baf290418>`, :ref:`snd_ctl_elem_id_set_name <doxid-group___control_1ga813d02a44a9d01a4a2fe81eda7a8670a>` and :ref:`snd_ctl_elem_id_set_index <doxid-group___control_1ga65af30a51becd092f6da1e357fc46094>`, etc. The callbacks should return 0 if successful, or a negative error code.

The find_elem callback is used to convert the given control element ID to the certain key value for the faster access to get, read and write callbacks. The key type is alias of unsigned long, so you can assign some static number (e.g. index of the array) to this value of the corresponding element, or assign the pointer (cast to :ref:`snd_ctl_ext_key_t <doxid-group___ctl_plugin___s_d_k_1gac73a66a3973afb51c4e585177647c693>`). When no key is defined or found, return :ref:`SND_CTL_EXT_KEY_NOT_FOUND <doxid-group___ctl_plugin___s_d_k_1gac1f0737189a30bbb1e4dcbf681df39fd>`. This callback is (very likely) required if you use get, read and write callbacks as follows. If you need to create a record dynamically (e.g. via malloc) at each find_elem call, the allocated record can be released with the optional free_key callback.

The get_attribute is a mandatory callback, which returns the attribute of the control element given via a key value (converted with find_elem callback). It must fill the control element type (:ref:`snd_ctl_elem_type_t <doxid-group___control_1gac42e0ed6713b62711af5e80b4b3bcfec>`), the access type (:ref:`snd_ctl_ext_access_t <doxid-group___ctl_plugin___s_d_k_1gaeedd1d7413b3025e9cede1b27e509de5>`), and the count (element array size). The callback returns 0 if successful, or a negative error code, as usual.

The get_integer_info, get_integetr64_info and get_enumerated_info callbacks are called to return the information of the given control element for each element type. For integer and integer64 types, the callbacks need to fill the minimal (imin), maximal (imax) and the step (istep) values of the control. For the enumerated type, the number of enum items must be filled. Additionally, the enum control has to define get_enumerated_name callback to store the name of the enumerated item of the given control element. All functions return 0 if successful, or a negative error code.

For reading the current values of a control element, read_integer, read_integer64, read_enumerated, read_bytes and read_iec958 callbacks are called depending on the element type. These callbacks have to fill the current values of the element in return. Note that a control element can be an array. If it contains more than one values (i.e. the count value in get_attribute callback is more than 1), *all* values must be filled on the given value pointer as an array. Also, note that the boolean type is handled as integer here (although boolean type doesn't need to define the corresponding info callback since it's obvious). These callbacks return 0 if successful, or a negative error code.

For writing the current values, write_integer, write_integer64, write_bytes, and write_iec958 callbacks are called as well as for read. The callbacks should check the current values and compare with the given values. If they are identical, the callbacks should do nothing and return 0. If they differ, update the current values and return 1, instead. For any errors, return a negative error code.

The subscribe_events callback is called when the application subscribes or cancels the event notifications (e.g. through mixer API). The current value of event subscription is kept in the subscribed field. The read_event callback is called for reading a pending notification event. The callback needs to fill the event_mask value, a bit-field defined as SND_CTL_EVENT_MASK_XXX. If no event is pending, return -EAGAIN. These two callbacks are optional.

The poll_descriptors_count and poll_descriptors callbacks are used to return the poll descriptor(s) via callbacks. As already mentioned, if the callback cannot set the static poll_fd, you can define these callbacks to return dynamically. Also, when multiple poll descriptors are required, use these callbacks. The poll_revents callback is used for handle poll revents.

