<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen>
<compounddef kind='class' id='type_jnc_scheduler' language='Jancy'>
<compoundname>Scheduler</compoundname>

<sectiondef>
<memberdef kind='function' id='function_jnc_scheduler_schedule' virt='abstract'>
<functionkind>named-function</functionkind>
<name>schedule</name>
<type>void</type>
<argsstring>(jnc.Scheduler safe* this, void function* proc ())</argsstring>
<param>
<declname>proc</declname>
<type>void function*</type>
<array>()</array>
</param>
<detaileddescription>
<para>Implement this abstract function to perform the required scheduling. Note that even though the argument has type of simple function pointer ``void function* ()``, the resulting scheduler will be capable of handling function pointers of *any* type</para>
</detaileddescription>
<location file='jnc_Scheduler.jnc' line='86' col='11'/>
</memberdef>

</sectiondef>
<briefdescription><para>This interface is used by Jancy compiler when creating *scheduled* function pointers.</para></briefdescription>
<detaileddescription>
<para>Often times it is necessary to postpone execution of a certain callback function (e.g. IO completion routine or other event handler). A realistic example would be this: IO completion event gets fired in some worker IO thread context, but we want to conveniently process it in the context of the main UI thread. Should you write this code in C, Java or any other traditional language, you would probably use a variation of the following approach:

1) allocate some struct;
2) use it to store IO completion event parameters (e.g. completion status, received data size, remote node address etc);
3) add this struct to some *request* list;
4) send some kind of UI message to wake up the main thread;
5) process the list of pending requests in the main thread.

Since this is such a typical problem in asynchronous IO programming and Jancy was conceived as *the* scripting language for IO programming, it is of no surprise that Jancy features a special facility to solve problems just like this in a much more elegant way.

Jancy has a concept of a *scheduled* function pointer, i.e. the pointer to a function which *requires* some specific execution environment. When you call a *scheduled* function pointer, the function it points to does not get invoked immediatly. Instead, it will be postponed until the execution environment is exactly what the function expects it to be.

Of course, Jancy compiler has *no idea* which environment is required for this particular function. But the programmer surely knows. So, the programmer can write a *scheduler* which will execute *abstract* function pointer in the proper execution environment. Then you take this scheduler and use it to create scheduled function pointers of *any* type.

.. rubric:: Sample code:

.. ref-code-block::

	import "sys_Lock.jnc"

	class LockScheduler
	{
		sys.Lock* m_lock;

		override schedule (void function* f ())
		{
			m_lock.lock ();
			f ();
			m_lock.unlock ();
		}
	}

	sys.Lock g_lock;
	typedef OnComplete (int x);

	work (OnComplete* onComplete)
	{
		// ...
		onComplete (100);
	}

	bar (int a, int b, int c)
	{
		printf ($"bar ($a, $b, $c) -- MUST be called under g_lock");
	}

	foo ()
	{
		LockScheduler scheduler;
		scheduler.m_lock = g_lock; // initialize scheduler

		(bar @ scheduler) (1, 2, 3); // schedule immediatly
		work (bar ~(10, 20) @ scheduler); // pass as completion routine
	}</para>
</detaileddescription>
<location file='jnc_Scheduler.jnc' line='80' col='7'/>
</compounddef>
</doxygen>
